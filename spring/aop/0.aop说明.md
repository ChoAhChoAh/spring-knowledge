# spring-aop
## AOP说明
### 1.声明式服务
了解aop之前需要先关注“声明式服务（Declarative Service）”这个概念，声明式服务可以理解为功能解耦的一种方式。  
它允许开发者通过声明而非硬编码的方式，达成某一个组件对另一个组件的引用和调用。  
声明式服务推荐使用注解或者配置文件的方式描述组件间的依赖关系和声明周期，减少代码耦合。  
### 2.OOP存在的问题
在声明式服务这个基础上，我们可以简单分析下面向对象编程无法解决的问题。  
对于常规业务，面向对象编程可以很好对业务进行拆解和实现，例如实现消息发送功能，最简单的链路为“创建连接”-“构建消息”-“发送消息”-“接受消息”-“解码消息”-“处理消息”，  
因此根据面向对象的设计理念，可以将整条业务链路的分解为“连接(connection)”、“消息(message)”、“生产者（producer）”、“消费者（consumer）”，“编解码器（encoder/decoder）”，“消息处理器（processor）”。
```
      ______________________________________________________________________________________________
     |                                                                                             |
[connection]   [producer]---[encoder]---SEND[message]--->[consumer]----[decoder]----[processor]    |
     |_____________________________________________________________________________________________|
```  
面向对象的思想可以帮助开发者纵向的分析和设计出合理的业务抽象，但是如果想在上述各对象的执行前后增加诸如数据校验(CHECK)、入参出参跟踪(LOG)等共性业务时，就会出现代码重复的问题。  
虽然可以通过将共性业务也封装成对象，将共性业务的调用缩减到一行代码，但是因为这种编码方式松散且难以维护，很难保证开发者在正确的位置进行正确的共性业务调用。
```
      ________________________________________________________________________________________________________________________________________________________
     |                                                                                                                                                       |
[connection]  CHECK/LOG--[producer]--CHECK/LOG--[encoder]--CHECK/LOG--SEND[message]--CHECK/LOG-->[consumer]--CHECK/LOG--[decoder]--CHECK/LOG--[processor]    |
     |_______________________________________________________________________________________________________________________________________________________|
```  
对于这种问题，如果可以采用声明式服务，只需要在目标方法上标注CHECK和LOG，便可实现统一的共性业务介入，在简化代码的同时实现共性业务的统一管理；  
并且由于声明是独立于编码，也可以提升代码检查的效率。
而早在1996年，Gregor Kiczales就已经提出了通过AOP（Aspect-Oriented Programming）的方式来解决上述问题。

### 3.AOP
#### 3.1 什么是AOP
Aspect-Oriented Programming直接翻译就是面向切面编程。在aop的概念中，系统被分解为切面和横切关注点，其逻辑更倾向于将不同的业务调用进行横向的组织。  
通过将横切的共性业务进行模块化，把具有横切性的切面代码织入到横切关注点上，从而增强了原有横切关注点的能力。  
```
 [BusinessObject]         [AspectOject] 
businessMethodA(){}      genericMethodA(){}
businessMethodB(){}      genericMethodB(){}
        \                    /
         \                 /
          \   weaving    /
       [EnhancedBusinessObject] 
    enhancebusinessMethodA(){ genericMethodA(); businessMethodA(); genericMethodB();}
    enhancebusinessMethodB(){ genericMethodA(); businessMethodB(); genericMethodB();}

```
这里需要先引入AOP联盟定义的aop术语：

| 术语 | 名称 | 含义 |
| :-----| :---- | :---- |
| concern | 关注点 | 特定的问题、概念或者应用程序重点关注的领域，例如安全检查、事务管理、性能监控等共性概念。 |
| crosscutting concern | 横切关注点 | 已通过代码实现，且散落在众多类或方法中的关注点 |
| aspect | 切面 | 模块化的关注点实现，将关注点分类并封装的代码块 |
| join point | 连接点 | 程序执行过程中的任意一个点（时刻） |
| advice | 增强（通知） | 在特定连接点执行的动作 |
| pointcut | 切入点 | 一组连接点的总称，一般采用通配的方式描述需要被增强的多个连接点 |
| introduction | 引介 | 为现有的类或者接口添加方法或者字段（进行功能附加，实现类似多重集成的效果） |
| mixin inheritance | 混入继承 | 将封装了一组功能的类，通过非继承的手段混入到一个已有的类中<br>,aop中的混入是通过引介实现。<br> 在java中用于模拟多重继承。 |
| weaving | 织入 | 将切面整合到存在连接点的类中 |

在代码层面，开发人员主要关注切面、连接点、增强、切入点、织入这几个主要术语，其他术语更多是在aop设计层面的抽象指导。  
通过了解上面的数据，aop的流程可以简单描述为：
开发人员将关注点进行分析，将横切关注点模块化成切面，通过织入，将某个特定功能的切面组装到切入点（多个连接点）上，让程序在运行是可以对原有功能进行增强，  
而程序运行时，增强会首先拦截并接管流程控制权，当增强允许放行时，功能才会真正执行，完成流程的流转。

#### 3.2 增强类型
在3.1中已经对aop的概念进行了解释说明，本小节主要说明增强的类型：
- 前置增强（before、pre）： 在连接点调用之前执行的增强。
- 后置增强（after、post）： 在连接点调用之后执行的增强。AspectJ的概念中，后置增强又被细分为三个类型：
    1. 返回增强（返回后增强）：连接点调用完成后的增强，可获得返回值。
    2. 异常增强（抛出后增强）：连接点调用出现异常抛出某种特性类型异常之后的增强
    3. 后增强：连接点的任何调用后，无论正常返回或者异常抛出的增强,可获得返回值。
- 环绕增强（around）：完整控制流程的增强，出本身增强的业务外，还负责主动调用连接点；可用于实现其他类型的增强。

#### 3.3 切入点类型
通过切入方式，可以将切入点分为如下两类：
- 静态标准切入：根据部署阶段的信息选择增强，例如“拦截某些类的getter方法”。
- 动态标准切入：根据运行时的信息选择增强，例如“拦截方法的返回值为空的情况”。

#### 3.4.主流的AOP实现技术
1. AspectJ
2. Spring AOP
3. JBoss 4

#### 3.5 其他术语
1. 拦截器（interceptor）：spring和Jboss通过拦截器来实现方法的拦截，在连接点出挂接一条拦截器链，对方法进行增强。拦截是实现AOP的策略之一（Aspectj是通过字节码生成技术实现，不属于拦截器范畴）。
2. AOP代理（AOP proxy）：被增强的对象引用，基于拦截方式实现AOP的基础，可以是动态代理，或者是字节码操作工具。
3. 目标对象（target object）：在基于拦截机制的AOP实现方案下，被增强的对象实例。


#### 3.6 AOP实现方案
##### 3.6.1 JDK动态代理
方式：拦截器式，借助反射实现被代理对象的目标方法调用。
优点：JDK1.3引入的技术，属于java标准库，只需要引入aop框架，无需依赖三方库。  
缺点：只能针对接口代理，无法避免反射带来的开销（虽然性能方面并不会很差）。
spring默认对接口代理时使用jdk动态代理。

##### 3.6.2 动态字节码生成
CGLIB(Code Generation Library)。  
优点：可对类进行代理，直接生成字节码，没有反射开销。
缺点：通过继承实现代理，无法代理final方法。

##### 3.6.3 自定义类加载器
自定义类加载器修改new操作符，利用java的类加载机制扩展。
优点：增强信息可以外置，例如通过xml配置；无反射开销。
缺点：非标准做法，且会破坏双亲委派机制，可能存在安全问题。

##### 3.6.4 语言扩展
AspecJ通过额外的语言和代码扩展支持AOP。  
优点：类型安全性高, 切面代码被直接编译到增强类中；文档丰富；性能损耗小。
缺陷：语法复杂；属于另一种语言，需要考虑维护性；无法单实例增强；切面复用较难；

#### 3.7 AOP的问题
##### 3.7.1 字段拦截
字段拦截可能会破坏java对象的封装，偏离了面向对象的思想，应尽量避免对字段的拦截，主要使用对方法的拦截。

##### 3.7.2 过多的切面织入
过多的切面织入导致代码执行无法被预测。  
应控制切面的使用规范，明确切面的使用范围。

##### 3.7.3 切面正交问题
多个切面相互影响导致程序运行结果偏离预期。  
开发切面时保证切面间的独立性，避免先后顺序的依赖。

##### 3.7.4 测试和调试
针对切面进行单独的功能测试，再对使用切面的业务进行组合测试，有限保证切面代码的正确性。
提供切面的文档或者说明，方便开发者调试时进行调用链跟踪。

##### 3.7.5 性能问题
切面的实现硬尽量简单，功能尽量单一，避免逻辑复杂的切面。

### 4.面向对象设计模式中可实现AOP的方式
#### 4.1 装饰器模式（Decorator）
允许在方法调用前后添加自定义行为。装饰器类和目前对象实现相同的几口，负责莫表对象的调用，并加入自定义代码。  
可以实现类似环绕通知的能力，但是需要针对每个目标类单独定制一个装饰器。编码量较大，且难以维护。
#### 4.2 观察者模式（Observer）
当被观察对象发生特定事件时，有多个对象可以接收通知。某些情况下可以达到AOP的后置通知或者前置通知效果，但是无法提供环绕增强。  
被观察者也需要通过编码实现一些通知发送的逻辑，可能于本身的业务无关，观察者也无法改变被观察者的执行流程。
#### 4.3 责任链模式（chain of responsibility）
允许将一个请求在一条对像链上传播，值到某个对象负责处理请求位置。和拦截器链实现AOP的方式相似，但是责任链模式下，对象需要关注责任链的细节，  
且每个需要责任链的方法都需要设置一个单独的责任链。
#### 4.4 总结
观察者和责任链模式都包含一个特性，就是将部分功能分散到其他对象中，这种思想类似aop的切面。  
但是通过面向对象的设计模式，还是无法避免硬编码和代码维护困难的问题，无法很好的代替aop。