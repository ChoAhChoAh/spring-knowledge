# spring-bean容器
## 配置文件的bean注入说明
在"spring/bean容器/1.容器注入bean方式"一文中的第一部分简要说明配置文件向容器注入bean的方式，本文将详细介绍不同的配置方式和配置文件注入如何解决bean之间依赖注入的问题
### 1.配置文件
spring的xml上下问容器会通过流加载xml配置文件，并解析文件中是否包含命名空间“http://www.springframework.org/schema/beans”，默认的解析器会提供四种基本元素的解析即“import”，“alias”，“bean”、“beans”(具体的源码分析将放“4.容器IOC原理”中说明)，  
因此最基础的bean配置文件如下，包含beans命名空间及其下定义的标签和属性，配置文件的跟文档结点必须为beans（官方文档：https://docs.spring.io/spring-framework/docs/5.3.36/reference/html/core.html#spring-core）：  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="data" class="org.xxx.bean.DataProcess" >
        <property name="id" value="1111"/>
    </bean>
    <bean class="org.xxx.bean.DataProcess"/>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>
</beans>
```
此时存在一个问题：既然spring默认支持四种标签的解析，那是否可以只定义bean标签，答案是虽然可以，但这是一种错误的定义方式。  
spring其代码层面可以不定义beans标签，直接把命名空间定义在bean标签,例如下方的配置，但这种定义方式只能骗过spring代码的运行，并不会进行bean的注入，如下的data也不会存在与上下文容器中，所以请严格参考官方文档：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<bean xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"
      id="data" class="org.lql.bean.DataProcess" >
            <property name="id" value="1111"/>
</bean>
```
spring也提供了其他命名空间供开发者使用，例如context命名空间及其下定义的标签和属性：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
    
    <context:component-scan base-package="org.lql.bean,org.lql.config"/>
</beans>
```
### 2.基础标签
#### 2.1 beans标签
beans标签是单个bean配置文件的根标签，spring的xml上下文容器解析到该标签时会继续递归的调用方法去进入该标签节点内，去解析它内部配置的其他标签（主要是bean和内部嵌套的beans标签）。  
beans标签主要有以下属性：
| 属性 | 属性名 | 用途 |
| :-----| :---- | :---- |
| profile | 环境配置 | 容器的环境，配合启动参数的profile使用 |
| default-lazy-init | 容器级别的懒加载配置 | 默认容器启动非懒加载，可以设置该属性为true开启容器级别的懒加载， |
| default-merge | 容器级别的合并策略 | 容器级别合并策略设置 |
| default-autowire | 容器级别的自动注入方式 | 和bean的autowire用法类似，只不过是容器级别的设置 |
| default-autowire-candidates | 容器级别的自动注入备选 | 和bean的自动注入备选类似，支持通配符配置 |
| default-init-method | 容器级别的统一初始化方法 | 和bean的init-method类似，可选beans下所有bean的初始化方法作为值 |
| default-destroy-method | 容器级别的统一销毁方法 | 和bean的destroy-method类似，可选beans下所有bean的销毁方法作为值 |

注意:
- beans标签是可以嵌套beans的，可以用于父子容器的设置，或者不同profile下容器的设置。
- 使用嵌套beans是，内部的beans需要配置在其他标签（bean、alias、context等）之后，否则会报错。

#### 2.2 bean标签的属性
bean标签用于描述期望加载到spring bean容器中的bean定义，实际就是bean定义类（BeanDefinition）的一个xml文档描述形式，主要有以下属性：
| 属性 | 属性名 | 用途 |
| :-----| :---- | :---- |
| id | bean的名称 | 虽然属性叫id，实际是bean容器中用于映射该bean的名称，<br> 获取bean的首要匹配键 |
| class | bean的全限定类名 | 用于创建bean的类全限定类名 |
| name | bean的别名 | bean容器缓存别名map中用于匹配bean的键 |
| scope | 作用域 | spring和springweb一共提供了四种作用域：<br> 1.singleton: 单例，同id的bean在容器中被缓存且只有一个 <br> 2.prototype: 原型，bean不会缓存在容器中，获取时创建新的 <br> 3.request: web环境下使用，每次请求创建一个新bean <br> 4.session: web环境下使用，每次会话创建一个新bean |
| depends-on | 当前bean依赖的bean的id | 该属性配置后spring容器会保证依赖的bean被先初始化 |
| autowire | 给当前bean自动注入其属性 | spring提供了四种模式：<br> 1.no: 默认值，spring不会对当前bean的属性进行自动注入 <br> 2.byType: 根据容器中的同类型的bean自动注入属性，<br> 当发现多个同类型bean时，报fatal <br> 3.byName: 使用容器中和当前bean属性名相同的bean自动注入，<br> 未找到则不做处理 <br> 4.constructor: 相当于byType的构造器版本，当发现多个同类的bean时报错 |
| autowire-candidate | 是否作为自动注入的候选 | 设置后该bean会在spring容器加载其他bean时考虑使用该bean进行byType注入，<br> 但是优先级低于ref和byName |
| lazy-init | 懒加载 | 只对单例bean生效的配置，设置为true时不会在容器启动时实例化并注入bean，<br> 只在获取时实例化和注入 |
| primary | 是否作为主要候选 | 当其他bean自动注入使用byType或者constructor时，<br> 如果多个候选中只有一个被标注primary，则使用标注了primary的bean |
| init-method | 初始化bean的方法 | 在bean的属性设置后被调用的自定义初始化方法，<br> 必须为无参方法 |
| destroy-method | 销毁bean的方法 | 在spring容器关闭时被调用的自定义销毁方法，<br> 必须为无参方法 |
| factory-bean | 工厂bean的id | 指定用于创建bean的工厂bean |
| factory-method | 工厂方法名称 | 指定用于创建bean的工厂方法,分以下两种场景：<br>1. 当使用factory-bean时，使用工厂bean的指定方法创建。<br> 2.不使用factory-bean，则配合class使用，通过指定的类静态方法创建。<br><br> 注意：<br> factory-bean的优先级高于class。<br> 使用constructor-arg来给方法的参数赋值。<br>setter注入可以配合工厂方法使用，但是方法注入（lookup-method）不行。<br><br>TODO: 官方提示自动装配不适用与工厂方法，但尚未验证出何种情况不适用，<br>目前通过autowire可以注入和被注入通过工厂方法创建的bean |
| abstract | 是否是抽象bean | 默认该值为false，设置true时表示当前bean是一个抽象bean，<br> 不会被容器实例化注入，只作为具体子类bean的父类定义 |
| parent | 设置父类关联 | 用于子类的bean接收父类bean的构造参数和属性，一般不使用 |
##### 2.2.1 bean的子标签
- meta标签：用于给bean定义增加一些元数据属性，配置的键值对会存储到BeanDefinition的attributes中（attributes继承自抽象类AttributeAccessorSupport，Map<String, Object>结构）。 
- constructor-arg标签：构造参数，该标签不仅表示类构造器中的参数，也可以用于工厂方法的参数列表（2.1 bean标签的属性中已经说明）。
- property标签：用于设置对象中域的值，配合setter方法使用，如果没有setter方法，运行会失败，列如idea等编译器也会在配置文件中给出错误提示。
- qualifier标签：给Bean定义提供的限定符，用以匹配字段或参数上的注解，从而实现细粒度的自动装配候选解析。实际非常鸡肋的标签，因为通过配置文件配置bean已经可以通过ref来指定注入，这个标签要配合注解使用，不如直接使用注解式来实现同等效果，参考官方文档（https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-autowired-annotation-qualifiers）
- lookup-method标签：用于方法注入，当出现bean和依赖的bean生命周期不同时使用，例如一个单例bean需要引用一个原型bean，参考官方文档：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-factory-method-injection
- replaced-method标签：用于方法替换，将已部署 bean 的现有方法实现替换为另一个方法实现，不太常用，参考官方文档：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-factory-arbitrary-method-replacement

##### 2.2.2 constructor-arg和property的下级标签
2.2中描述的bean子标签中，constructor-arg和property标签可以使用多个下级标签，此处对常用的进行讲解：
| 标签 | 用法 | 
| :-----| :---- | 
| list标签 | 用于配置列表类型的属性，列表中的属性值可以是简单类型和对象类型，<br> 当为对象类型时，可以直接使用bean标签生成新的实例，<br>也可以使用ref标签关联一个已有的bean | 
| set标签 | 和list标签使用类似，集合类型，无法添加重复的值，可参考list标签的用法 |
| map标签 | 用于配置哈希表类型的属性，下级标签需要使用entry配置key和value,<br>当value为对象时，可以使用嵌套的bean标签、ref属性或者ref标签 |
| props标签 | 用于配置properties类型的属性，下级标签需要使用prop配置key和value,<br>key是prop标签的属性，value为下级文本节点 |
| ref标签 | 用于关联引用bean类型的属性 |
其他下级标签的使用可以参考官方文档：
- 内部bean标签：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-inner-beans
- 空值标签：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-null-element
- p命名空间标签：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-p-namespace
- c命名空间标签：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-c-namespace
- 符合属性标签：https://docs.spring.io/spring-framework/docs/5.3.37-SNAPSHOT/reference/html/core.html#beans-compound-property-names
举例集合标签和ref标签的使用
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="simple1" class="org.lql.bean.SimpleObject"></bean>
    <bean id="simple2" class="org.lql.bean.SimpleObject"></bean>
    <bean id="simple3" class="org.lql.bean.SimpleObject"></bean>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>

    <bean id="aBean" class="org.lql.bean.ABean" init-method="doInit" destroy-method="doDestory">
        <property name="dataSource" ref="dataSource"></property>
        <property name="simpleObjectList">
            <list>
                <ref bean="simple1"></ref>
                <ref bean="simple2"></ref>
            </list>
        </property>
        <property name="simpleObjectSet">
            <set>
                <ref bean="simple1"></ref>
                <ref bean="simple3"></ref>
            </set>
        </property>
        <property name="simpleObjectMap">
            <map>
                <entry key="simple2" value-ref="simple2"></entry>
                <entry key="simple3"><ref bean="simple3"></ref></entry>
            </map>
        </property>
    </bean>

</beans>
```

#### 2.3.alias标签
用于配置某个bean的别名
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <alias name="fabean" alias="anothernameoffabean"></alias>
    <bean id="fabean" class="org.lql.bean.factory.CustomeFactory1" factory-method="createABean">
        <constructor-arg name="name" value="ac"></constructor-arg>
        <constructor-arg name="value" value="ca"></constructor-arg>
    </bean>
</beans>
```
#### 2.4.import标签
用于引入其他配置文件，因为项目根据规模可能会拆分除不同的配置文件，避免单个配置文件过长产生的难维护问题：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="simple1" class="org.lql.bean.SimpleObject"></bean>
    <bean id="simple2" class="org.lql.bean.SimpleObject"></bean>
    <bean id="simple3" class="org.lql.bean.SimpleObject"></bean>
    <import resource="classpath:applicationContext1.xml"></import>
</beans>
```

#### 2.5.description标签
用于配置任意bean、属性、beans的说明，无其他作用
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <description>外层容器</description>
</beans>
```

### 3.其他自定义标签（如context标签）
spring的配置文件除了可以使用基础标签外，还可以使用自定义标签。spring官方提供了诸多命名空间的自定义标签用于不同的功能，以context标签为例。  
使用这类自定义标签需要引入命名空间，举例如下：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
   
    <context:component-scan base-package="org.lql.bean,org.lql.config"/>
    <context:property-placeholder location="classpath:jdbc.properties"/>
</beans>
```
上述使用了spring官方的提供的context自定义标签，用于配置包扫描路径。
除了context标签外，spring官方还提供了其他各种命名空间（可查看官网http://www.springframework.org/schema/），常用的命名空间：
- beans（基础）：定义和配置 Spring Bean 的基础命名空间
- context：用于加载和访问应用程序上下文相关的资源和功能
- aop：支持面向切面编程 (AOP) 的相关配置
- tx：配置声明性事务管理
- jdbc：配置 JDBC 相关功能，例如数据源和 JdbcTemplate
- jpa：配置 JPA (Java Persistence API) 相关功能
- mvc：配置 Spring MVC 的相关功能
- security：配置 Spring Security 的相关功能
- util：用于一些通用的工具类和实用程序
- task：配置任务调度相关功能
- cache：配置缓存支持
- p：简化property子标签的配置，可以直接在bean属性中通过p:配置
- c：简化constructor-arg子标签的配置，可以直接在bean属性中通过c:_配置
除了spring官方提供的这些自定义标签外，其他三方依赖如dubbo等框架也支持了各自的自定义命名空间。  
不过目前由于springboot和springcloud的发展，开箱即用成为主流，这些配置存在一定的学习成本和配置维护成本，因此目前在新项目中已经很少使用，当前主流的方式为注解+yml（properties文件）。

### 4.基于配置文件的bean创建注入方式
本节将通过举例，说明通过xml配置bean创建注入spring容器的四种方法，仅作用法展示，实际开发未必会按照例子中的举例使用。
#### 4.1 构造方法+bean标签
通过类的构造方法，创建非自定义bean实例注入容器
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
   <!-- 空参构造方法创建对象实例 + setter方法设置对象域的值 -->
    <bean class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc://localhost:3306/mybatis"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>

    <!-- 带参构造方法设置对象域的值并创建对象实例 -->
    <bean id="aBean" class="org.lql.bean.ABean" init-method="doInit" destroy-method="doDestory">
         <meta key="meta1" value="metav1"/>
         <constructor-arg name="a" value="12345"></constructor-arg>
    </bean>
</beans>
```
#### 4.2 静态工厂方法+bean标签
DriverManager通过静态工厂方法创建数据库连接：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean class="java.lang.Class" factory-method="forName">
        <constructor-arg name="className" value="com.mysql.jdbc.Driver"/>
    </bean>
    <bean id="connection" class="java.sql.DriverManager" factory-method="getConnection" 
    scope="prototype">
        <constructor-arg name="url" value="jdbc:mysql:///mybatis"/>
        <constructor-arg name="user" value="root"/>
        <constructor-arg name="password" value="root"/>
    </bean>
</beans>
```
自定义静态工厂方法创建bean实例，使用constructor-arg赋值方法参数：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="fabean" class="org.lql.bean.factory.CustomeFactory1" factory-method="createABean">
        <constructor-arg name="name" value="ac"></constructor-arg>
        <constructor-arg name="value" value="ca"></constructor-arg>
    </bean>
</beans>
```
java代码：
```java
public class CustomeFactory1 {

    public static ABean createABean(String name,String value){
        ABean abean = null;
        if(null!=name||name.length()>0){
            // ... doSomething
            abean = new ABean();
            // ... doSomething
        }
        if(null!=value||value.length()>0){
            // ... doSomething
        }
        return abean;
    }
}
```
此种方法适用于非自定义类但使用静态工厂方法才能创建的类实例，或者想要在实例化bean前进行自定义操作的自定义类。

#### 4.3 实例工厂方法+bean标签
SimpleDateFormat的实例工厂方法parse创建date实例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="simpleDateFormat" class="java.text.SimpleDateFormat">
        <constructor-arg name="pattern" value="yyyy-MM-dd HH:mm:ss"/>
    </bean>
    <bean id="date" factory-bean="simpleDateFormat" factory-method="parse">
        <constructor-arg name="source" value="2023-08-27 07:20:00"/>
    </bean>
</beans>
```
此种方法适用于非自定义类但使用实例工厂方法才能创建的类实例，或者想要在实例化bean前进行自定义操作的自定义实例工厂类。

#### 4.4 实现FactoryBean接口+bean标签
spring官方提供了FactoryBean工厂接口用于开发者可自定义实例化逻辑。
FactoryBean的实现类：
```java
public class CustomFactoryBean implements FactoryBean<SimpleObject> {

    @Override
    public SimpleObject getObject() throws Exception {
        SimpleObject simpleObject = null;
        // doSomething
        simpleObject = new SimpleObject();
        // doSomething
        return simpleObject;
    }

    @Override
    public Class<?> getObjectType() {
        return SimpleObject.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
```
配置文件：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="customeSimpleObject" class="com.lql.bean.factory.CustomFactoryBean"/>
</beans>
```
注意：
- 此种方式实例化的bean，只会在bean使用时才会创建，并不会在容器启动时创建（而自定义的静态和实例工厂都会在容器启动时创建bean实例）

### 5.依赖注入
spring配置文件支持以下方式解决bean之间的依赖注入问题：
1. ref属性或ref标签
2. autowire属性，参考2.2中的属性说明
3. lookup-method标签，用于不同生命周期bean间的因哟ing，参考2.2.1中bean子标签的说明
举例如下：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="simple1" class="org.lql.bean.SimpleObject"></bean>
    <bean id="simple2" class="org.lql.bean.SimpleObject"></bean>

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>

    <bean id="aBean" class="org.lql.bean.ABean">
        <property name="dataSource" ref="dataSource"></property>
        <property name="simpleObjectList">
            <list>
                <ref bean="simple1"></ref>
                <ref bean="simple2"></ref>
            </list>
        </property>
    </bean>

    <bean id="fbbean" autowire="byName" class="org.lql.bean.factory.CustomeFactory2" factory-bean="customeFactory2" factory-method="createBBean">
        <constructor-arg name="key" value="bb"></constructor-arg>
    </bean>
    <bean id="cBean" class="org.lql.bean.CBean" autowire="byName"/>
    <bean id="cBean2" class="org.lql.bean.CBean" autowire="byType"/>

</beans>
```

### 6.基于xml配置整合三方技术
#### 6.1 使用spring基础标签整合
本节以mybatis为例，讲解spring使用基础标签整合mybatis。  
##### 6.1.1 传统方式整合使用mybatis
###### 6.1.1.1 引入数据库连接池、mybatis依赖
```xml
<dependencies>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.4.0</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.16</version>
    </dependency>
</dependencies>
```
注意打包时需要对resources和java路径下的资源文件进行处理，需要如下配置：
```xml
<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.yml</include>
                <include>**/*.yaml</include>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.*</include>
            </includes>
        </resource>
    </resources>
</build>
```
###### 6.1.1.2 编写实体类、mapper接口和mapper.xml
mapper.xml
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.lql.mapper.TaskMapper">
    <select id="getAllTask" resultType="org.lql.bean.Task">
        select * from task
    </select>
</mapper>
```
mapper接口和实体类
```java
public interface TaskMapper {
    List<Task> getAllTask();
}

@Data
public class Task {
    private Integer id;
    private String name;
    private String type;
    private String status;
    private String desc;
}
```
###### 6.1.1.3 编写mybatis配置文件
注意mappers可以配置类路径、文件路径、类名和基础包路径，基础包路径只有在mapper.xml和mapper接口在同路径下时才可用
mybatis-config.xml
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://xx.xx.xx.xx:3306/task"/>
                <property name="username" value="root"/>
                <property name="password" value="xxxx"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="mapper/TaskMapper.xml"/>
    </mappers>
</configuration>
```
###### 6.1.1.4 通过编码引入SqlSessionFactory和相关实例
1. 通过资源类导入mybatis配置文件。
2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory。
3. 使用SqlSessionFactory创建SqlSession获取mapper查询数据。
```java
public class MyBatisTest {

    public static void main(String[] args) throws IOException {
        InputStream resourceAsStream = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory = builder.build(resourceAsStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        TaskMapper mapper = sqlSession.getMapper(TaskMapper.class);
        List<Task> allTask = mapper.getAllTask();
    }
}
```
###### 6.1.1.5 问题
通过最普通的方式引入mybatis时，需要额外配置mybatis的配置文件，且连接池、SqlSessionFactory、SqlSession均需要开发者自己维护。  
使用和维护的成本较高。

##### 6.1.2 spring基础标签整合mybatis
通过6.1.1可知，原始方式需要开发人员自己维护mybatis的各种实例，因此mybatis也提供了mybatis-spring来将重要的实例交给spring容器管理。  
spring基础标签整合mybatis步骤如下。
###### 6.1.2.1 引入依赖
在6.1.1的基础上，额外引入spring-jdbc和mybatis-spring依赖，注意mybatis-spring依赖和mybatis、spring的关联版本可以参考官方文档：https://mybatis.org/spring/
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.3.31</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis-spring</artifactId>
        <version>2.1.2</version>
    </dependency>
</dependencies>
```
###### 6.1.2.2 编写spring xml文件注入mybatis实例
从上到下分别配置数据库连接池、SqlSessionFactoryBean和MapperScannerConfigurer
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans  xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://60.188.59.58:3306/task"/>
        <property name="password" value="123"/>
        <property name="username" value="root"/>
    </bean>

    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="org.lql.mapper"/>
    </bean>
</beans>
```
###### 6.1.2.3 实体类、mapper接口和mapper xml
实体类、mapper接口和mapper xml文件和6.1.1保持一致，但是注意，如果采用MapperScannerConfigurer扫描mapper，  
需要保证mapper接口和mapper xml文件在同一包下。否则进行配置基础包路径的扫描和自动注入mapper代理类，导致功能无法使用。

###### 6.1.2.4 获取容器中的mapper查询数据
因为MapperScannerConfigurer帮助开发者进行扫描注入mapper代理实例，因此开发者无需在spring的xml中再配置mapper bean。
```java
public class MybatisSpringTest {

    public static void main(String[] args) {
        ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("applicationContext-mybatis.xml");
        TaskMapper bean = classPathXmlApplicationContext.getBean(TaskMapper.class);
        List<Task> allTask = bean.getAllTask();
        System.out.println(allTask);
    }
}
```
此种方式的优势在于，如果项目使用了spring，可以用统一的方式配置和管理容器中的mybaits实例。

###### 6.1.2.5 spring集成mybatis原理
此小节重点分析SqlSessionFactoryBean和MapperScannerConfigurer帮助开发者实现了什么逻辑来简化配置。  
第一部分： SqlSessionFactoryBean
通过查看SqlSessionFactoryBean的源码，该类实现了FactoryBean、InitializingBean两个spring提供的接口。
```java
public class SqlSessionFactoryBean
    implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ContextRefreshedEvent> {
}
```
FactoryBean用于向spring容器注入实例(延迟注入)，InitializingBean则在实例创建、完成属性赋值后的执行。  
SqlSessionFactoryBean实现InitializingBean接口方法的代码如下(仅截取了主要代码)：
```java
public class SqlSessionFactoryBean
    implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ContextRefreshedEvent> {
    // ...
    private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
    // ...
    @Override
    public void afterPropertiesSet() throws Exception {
      notNull(dataSource, "Property 'dataSource' is required");
      notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
      state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),
          "Property 'configuration' and 'configLocation' can not specified with together");
    
      this.sqlSessionFactory = buildSqlSessionFactory();
    }
    // ...
    protected SqlSessionFactory buildSqlSessionFactory() throws Exception {
        // ...
        return this.sqlSessionFactoryBuilder.build(targetConfiguration);
    }
    // ...
}
```
上述代码中，afterPropertiesSet方法调用了buildSqlSessionFactory方法，而buildSqlSessionFactory在进行了一些列操作后，最终使用sqlSessionFactoryBuilder.build方法创建了一个SqlSessionFactory。  
而SqlSessionFactoryBuilder则是直接硬编码的方式作为属性被SqlSessionFactoryBean持有。  
因此SqlSessionFactoryBean对InitializingBean接口的实现实际就是在创建SqlSessionFactory，并将创建的sqlSessionFactory引用赋值给SqlSessionFactoryBean持有的sqlSessionFactory域。

再来看SqlSessionFactoryBean实现的FactoryBean方法源码：
```java
public class SqlSessionFactoryBean
    implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ContextRefreshedEvent> {
    // ...
    @Override
    public SqlSessionFactory getObject() throws Exception {
        if (this.sqlSessionFactory == null) {
          afterPropertiesSet();
        }
        return this.sqlSessionFactory;
    }
    // ...
}
```
该方法实际就是调用了SqlSessionFactoryBean实现的InitializingBean的afterPropertiesSet首先创建sqlSessionFactory，  
然后在程序调用SqlSessionFactoryBean实现FactoryBean的getObject方法时，将创建的sqlSessionFactory返回给调用者。  
因此可以总结，mybatis通过实现spring提供的接口FactoryBean和InitializingBean，创建并向spring容器中注入SqlSessionFactory实例，以备后续使用。

第二部分： MapperScannerConfigurer
MapperScannerConfigurer的源码如下,通过实现树看，其实现了BeanDefinitionRegistryPostProcessor、InitializingBean等spring提供的接口：
```java
public class MapperScannerConfigurer
    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {
}
```
BeanDefinitionRegistryPostProcessor本质是一个BeanFactoryPostProcessor，也就是Bean工厂后置处理器，用于在spring容器初始化时，向容器中注册bean定义,  
MapperScannerConfigurer实现了postProcessBeanDefinitionRegistry的postProcessBeanDefinitionRegistry方法，源码如下(仅截取主要源码)：
```java
public class MapperScannerConfigurer
    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware { 
        // ...
        @Override
        public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
            if (this.processPropertyPlaceHolders) {
                processPropertyPlaceHolders();
            }
            ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
            // ...
            scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
        }
        // ...
}
```
上述实现的源码创建了ClassPathMapperScanner，给入postProcessBeanDefinitionRegistry参数中的registry，最后调用了ClassPathMapperScanner的scan方法（仅截取主要源码）：
```java
public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {
    // ...
    public int scan(String... basePackages) {
    		int beanCountAtScanStart = this.registry.getBeanDefinitionCount();
    		doScan(basePackages);
    		// Register annotation config processors, if necessary.
    		if (this.includeAnnotationConfig) {
    			AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
    		}
    		return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
    	}
    // ...
    protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    	Assert.notEmpty(basePackages, "At least one base package must be specified");
    	Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    	for (String basePackage : basePackages) {
    		Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
    		for (BeanDefinition candidate : candidates) {
    			// ...
    			if (checkCandidate(beanName, candidate)) {
                    // ...
    				registerBeanDefinition(definitionHolder, this.registry);
    			}
    		}
    	}
    	return beanDefinitions;
    }
}
```
doScan方法获取到设置的扫描基础包路径，循环每一个包路径，通过findCandidateComponents扫描其下的bean定义备选者，再次循环备选的bean定义，检查后将bean定义注册到spring容器中。  
这一步实际是在获取所有的mapper，将其组装成bean定义注册到spring容器的bean定义map中用于后续处理。  

上述doScan执行后，方法执行会返回到子类ClassPathMapperScanner的doScan方法中,之后会调用processBeanDefinitions处理bean定义：
```java
public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner {
    // ...
    private Class<? extends MapperFactoryBean> mapperFactoryBeanClass = MapperFactoryBean.class;
    // ...
    @Override
    public Set<BeanDefinitionHolder> doScan(String... basePackages) {
        Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);
        if (beanDefinitions.isEmpty()) {
            LOGGER.warn(() -> "No MyBatis mapper was found in '" + Arrays.toString(basePackages)+ "' package. Please check your configuration.");
        } else {
            processBeanDefinitions(beanDefinitions);
        }
        return beanDefinitions;
    }
    // ...
    private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
        AbstractBeanDefinition definition;
        BeanDefinitionRegistry registry = getRegistry();
        for (BeanDefinitionHolder holder : beanDefinitions) {
            // ...
            definition.setBeanClass(this.mapperFactoryBeanClass);
            // ...
            if (!explicitFactoryUsed) {
                LOGGER.debug(() -> "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'.");
                definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
            }
            // ...
        }
    }
}
``` 
processBeanDefinitions方法循环所有扫描出来的备选mapper的bean定义，将其beanClass强行改为MapperFactoryBean类型，这部分实际就是mybatis中的原理。  
因为mapper在定义时都是接口，接口实际时无法实例化对象的，此处可以看下MapperFactoryBean及其继承实现树(仅截取主要源码)：
```java
public class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {
    // ...
    @Override
    public T getObject() throws Exception {
        return getSqlSession().getMapper(this.mapperInterface);
    }
    // ...
}

public abstract class SqlSessionDaoSupport extends DaoSupport {
    private SqlSessionTemplate sqlSessionTemplate;
    // ...
}
public class SqlSessionTemplate implements SqlSession, DisposableBean {
    // ...
    private final SqlSessionFactory sqlSessionFactory;
    // ...
}
```
MapperFactoryBean也实现了spring提供的FactoryBean接口，最终通过mybatis自己的机制getSqlSession().getMapper(this.mapperInterface)创建并向容器中注入代理mapper实例，生成代理mapper的源码此处不在进行分析，可以参考mybatis的原理分析。  
此外MapperFactoryBean继承了SqlSessionDaoSupport，SqlSessionDaoSupport持有的SqlSessionTemplate则是持有了SqlSessionFactory，  
这也意味着MapperFactoryBean需要使用先前通过SqlSessionFactoryBean创建的SqlSessionFactory来进行数据库操作。  
但是sqlSessionFactory在此处时如何注入的，可以再看下ClassPathMapperScanner的processBeanDefinitions方法，该方法通过definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)，  
将mapper的bean定义自动注入类型设置为了按类型注入，因此再spring容器实例化各个bean的时候，会检查容器中是否存在SqlSessionFactory，存在则自动注入到mapper中。  

##### 6.1.3 总结
通过6.1.1和6.1.2两部分内容可以看出，从直接集成mybatis，到使用spring集成mybatis，实际上就是通过实现spring提供的一系列接口完成，这也是spring能够被称之为框架的原因。
spring通过对外提供FactoryBean、BeanDefinitionRegistryPostProcessor等接口，以允许开发者在已有功能模块的基础上，将实例的创建和管理交给spring，这些接口就像钩子函数，开发者只需要实现，剩下则由spring自己运行。
作为java开发者，可以通过spring提供的这些机制实现更加丰富的功能，也可以参考spring的设计实现扩展性强的框架。

#### 6.2 通过自定义命名空间引入
例如spring-context的component-scan、property-placeholder或者dubbo的相关配置，可以通过引入自定义命名空间，使用包扫描、SpEL表达式、dubbo注册中心配置等功能。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://dubbo.apache.org/schema/dubbo 
       http://dubbo.apache.org/schema/dubbo/dubbo.xsd">
    <!--配置包扫描-->
    <context:component-scan base-package="org.xxx"/>
    <!--配置配置文件解析-->
    <context:property-placeholder location="classpath:a.properties"/>
    <!--配置dubbo应用名称-->
    <dubbo:application name="dubbo-consumer"/>
    <!--配置dubbo注册中心地址-->
    <dubbo:registry address="zookeeper://localhost:2181"/>
</beans>
```
##### 6.2.1 解析自定义命名空间
在本文的“2.1 beans标签”部分内容中，有说明spring的基础标签会被spring的框架源码解析并处理，而自定义标签同样会被解析处理，只不过走的时另一个逻辑分支。  
截取部分源码如下：
```java
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
    // ...
    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    	if (delegate.isDefaultNamespace(root)) {
    		NodeList nl = root.getChildNodes();
    		for (int i = 0; i < nl.getLength(); i++) {
    			Node node = nl.item(i);
    			if (node instanceof Element) {
    				Element ele = (Element) node;
    				if (delegate.isDefaultNamespace(ele)) {
    					parseDefaultElement(ele, delegate);
    				}
    				else {
    					delegate.parseCustomElement(ele);
    				}
    			}
    		}
    	}
    	else {
    		delegate.parseCustomElement(root);
    	}
    }
    // ...
}
```
对于使用xml配置注入bean到容器的方式，ClassPathXmlApplicationContext会通过DefaultBeanDefinitionDocumentReader去解析xml文件，使用parseBeanDefinitions方法。  
parseBeanDefinitions方法会从根节点<beans>开始解析，判断其中命名空间是否未默认命名空间，如果时默认命名空间，则会去解析“import”，“alias”，“bean”、“beans”这四个基础标签，  
否则会走parseCustomElement这个方法去处理自定义标签。

parseCustomElement的源码如下：
```java
public class BeanDefinitionParserDelegate {
    // ...
    @Nullable
    public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
        String namespaceUri = getNamespaceURI(ele);
        if (namespaceUri == null) {
            return null;
        }
        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
        if (handler == null) {
            error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
            return null;
        }
        return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
    }
    // ...
}
```
该方法会获取标签元素的命名空间，并通过NamespaceHandlerResolver的resolve方法获取一个命名空间处理器，这里首先要看下NamespaceHandlerResolver。  
NamespaceHandlerResolver是一个顶层接口，在spring中有一个实现类DefaultNamespaceHandlerResolver，默认情况下DefaultNamespaceHandlerResolver会从   
DEFAULT_HANDLER_MAPPINGS_LOCATION（META-INF/spring.handlers）位置获取处理器，而在spring-context的jar包内，可以在META-INF下找到一个spring.handlers文件，  
该文件记录了如下内容：
```
http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler
http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler
http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler
http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler
```
也就是说，spring默认通过META-INF/spring.handlers这个描述文件，提前定义了一堆命名空间处理器，这些处理器在spring容器启动时，就已经加载到容器中。  
此时再看DefaultNamespaceHandlerResolver的resolve方法
```java
public class DefaultNamespaceHandlerResolver implements NamespaceHandlerResolver {
    // ...
    public NamespaceHandler resolve(String namespaceUri) {
    	Map<String, Object> handlerMappings = getHandlerMappings();
    	Object handlerOrClassName = handlerMappings.get(namespaceUri);
    	if (handlerOrClassName == null) {
    		return null;
    	}
    	else if (handlerOrClassName instanceof NamespaceHandler) {
    		return (NamespaceHandler) handlerOrClassName;
    	}
    	else {
    		String className = (String) handlerOrClassName;
    		try {
    			Class<?> handlerClass = ClassUtils.forName(className, this.classLoader);
    			if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {
    				throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri +
    						"] does not implement the [" + NamespaceHandler.class.getName() + "] interface");
    			}
    			NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
    			namespaceHandler.init();
    			handlerMappings.put(namespaceUri, namespaceHandler);
    			return namespaceHandler;
    		}
    		catch (ClassNotFoundException ex) {
    			throw new FatalBeanException("Could not find NamespaceHandler class [" + className +
    					"] for namespace [" + namespaceUri + "]", ex);
    		}
    		catch (LinkageError err) {
    			throw new FatalBeanException("Unresolvable class definition for NamespaceHandler class [" +
    					className + "] for namespace [" + namespaceUri + "]", err);
    		}
    	}
    }
    // ...
}
```
resolve方法会从容器的handlerMappings缓存中通过命名空间尝试获取命名空间处理器，如果没有获取到，则会走到else的分支中，实例化这个命名空间处理器，  
并调用init()方法初始化,初始化后，放入handlerMappings，init方法如下：
```java
public class ContextNamespaceHandler extends NamespaceHandlerSupport {
	@Override
	public void init() {
		registerBeanDefinitionParser("property-placeholder", new PropertyPlaceholderBeanDefinitionParser());
		registerBeanDefinitionParser("property-override", new PropertyOverrideBeanDefinitionParser());
		registerBeanDefinitionParser("annotation-config", new AnnotationConfigBeanDefinitionParser());
		registerBeanDefinitionParser("component-scan", new ComponentScanBeanDefinitionParser());
		registerBeanDefinitionParser("load-time-weaver", new LoadTimeWeaverBeanDefinitionParser());
		registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
		registerBeanDefinitionParser("mbean-export", new MBeanExportBeanDefinitionParser());
		registerBeanDefinitionParser("mbean-server", new MBeanServerBeanDefinitionParser());
	}
}
```
上述代码截取了ContextNamespaceHandler的init方法，该子类只有init一个方法，方法向spring容器注册了若干bean定义解析器，  
并且从名字可以看出，这些解析器就是再spring xml文件中配置的context功能标签，例如“property-placeholder”和"component-scan"。

再回到parseCustomElement方法，该方法最终调用了NamespaceHandler的parse方法，而各个NamespaceHandler的实现类例如ContextNamespaceHandler，  
并没有实现parse方法，而是调用其父类NamespaceHandlerSupport的parse方法，代码如下：
```java
public abstract class NamespaceHandlerSupport implements NamespaceHandler {
    // ...
    @Override
    @Nullable
    public BeanDefinition parse(Element element, ParserContext parserContext) {
    	BeanDefinitionParser parser = findParserForElement(element, parserContext);
    	return (parser != null ? parser.parse(element, parserContext) : null);
    }
    // ...
}
``` 
NamespaceHandlerSupport的parse方法则通过标签元素的名称，去匹配具体的BeanDefinitionParser，进行解析，此处以PropertyPlaceholderBeanDefinitionParser为例：
```java
class PropertyPlaceholderBeanDefinitionParser extends AbstractPropertyLoadingBeanDefinitionParser {
    // ...
	@Override
	protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
		super.doParse(element, parserContext, builder);

		builder.addPropertyValue("ignoreUnresolvablePlaceholders",
				Boolean.valueOf(element.getAttribute("ignore-unresolvable")));

		String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);
		if (StringUtils.hasLength(systemPropertiesModeName) &&
				!systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) {
			builder.addPropertyValue("systemPropertiesModeName", "SYSTEM_PROPERTIES_MODE_" + systemPropertiesModeName);
		}

		if (element.hasAttribute("value-separator")) {
			builder.addPropertyValue("valueSeparator", element.getAttribute("value-separator"));
		}
		if (element.hasAttribute("trim-values")) {
			builder.addPropertyValue("trimValues", element.getAttribute("trim-values"));
		}
		if (element.hasAttribute("null-value")) {
			builder.addPropertyValue("nullValue", element.getAttribute("null-value"));
		}
	}
    // ...
}
```

PropertyPlaceholderBeanDefinitionParser继承自AbstractSingleBeanDefinitionParser（实际中间还有多层继承树），  
AbstractSingleBeanDefinitionParser的parse方法通过parseInternal完成子类的doParse方法调用，  
从该doParse方法可以看出，其主要是向spring容器注册了一个PropertySourcesPlaceholderConfigurer，  
PropertySourcesPlaceholderConfigurer本质上是一个BeanFactoryPostProcessor，用于处理占位符。

##### 6.2.2 总结
从6.2.1的源码分析，无论是spring自己的提供的自定义命名空间，还是三方例如dubbo等技术自定义的命名空间，  
为了适配spring框架的逻辑，都通过以下步骤实现对接：
step1: 确定命名空间名称、schema虚拟路径、标签名称  
step2: 编写schema约束文件.xsd (spring.schemas和.xsd文件用于后续再xml文件中配置标签校验使用)
step3: 在类加载路径下创建META目录，编写约束映射文件spring.schemas和处理器映射文件spring.handlers  
step4: 实现NamespaceHandler接口，在init方法中注册BeanDefinitionParser的实现类
step5: 实现自定义的BeanDefinitionParser解析器，在parse方法中注册bean后置处理器或者bean工厂后置处理器  
step6: 实现自定义的bean后置处理器或者bean工厂后置处理器
通过以上步骤，即可实现一个自定义的命名空间和相关业务逻辑，通过applicationContext.xml中引入自定义的命名空间并配置对应的标签来使用自定义的功能。